
from google.colab import files
print("► Please select your Excel file (sheet='BTC_Hourly'):")
uploaded = files.upload()
fname = next(iter(uploaded.keys()))

# 1) Import libraries
import pandas as pd, numpy as np, matplotlib.pyplot as plt, seaborn as sns
from IPython.display import display
from scipy.stats import pearsonr, spearmanr, ttest_ind, ttest_1samp
from statsmodels.formula.api import ols, logit
from statsmodels.tsa.stattools import grangercausalitytests
from sklearn.metrics import roc_auc_score
from sklearn.feature_selection import mutual_info_regression
import statsmodels.api as sm

sns.set(style="whitegrid")
%matplotlib inline

# 2) Load the data
df_raw = pd.read_excel(fname, sheet_name='BTC_Hourly', skiprows=[1,2], index_col=0, engine='openpyxl')
df_raw.index = pd.to_datetime(df_raw.index)
df_raw = df_raw[['Close']].dropna()

# 3) Set different timeframes to test
timeframes = ['1H', '2H', '3H', '4H']
all_results = {}

# 4) Calculate indicators (EMA50, EMA100, RSI)
def compute_indicators(df):
    df['EMA50']  = df['Close'].ewm(span=50, adjust=False).mean()
    df['EMA100'] = df['Close'].ewm(span=100, adjust=False).mean()
    delta     = df['Close'].diff()
    gain      = delta.where(delta > 0, 0.0)
    loss      = -delta.where(delta < 0, 0.0)
    avg_gain  = gain.rolling(14).mean()
    avg_loss  = loss.rolling(14).mean()
    df['RSI'] = 100 - (100 / (1 + avg_gain / avg_loss))
    df['Return'] = df['Close'].pct_change()
    df.dropna(inplace=True)
    return df

# 5) Run analysis for each timeframe
def analyze(df):
    results = {}

    # Correlation tests
    corrs = []
    for col in ['RSI', 'EMA50', 'EMA100']:
        pr, pp = pearsonr(df[col], df['Return'])
        sr, sp = spearmanr(df[col], df['Return'])
        corrs.append({'Indicator': col, 'Pearson_r': pr, 'Pearson_p': pp,
                      'Spearman_rho': sr, 'Spearman_p': sp})
    results['correlation'] = pd.DataFrame(corrs)

    # Linear & Logistic regression
    lm = ols('Return ~ RSI + EMA50 + EMA100', data=df).fit()
    df['Direction'] = (df['Return'] > 0).astype(int)
    logm = logit('Direction ~ RSI + EMA50 + EMA100', data=df).fit(disp=False)
    auc = roc_auc_score(df['Direction'], logm.predict(df))
    results['linreg'] = lm
    results['auc'] = auc

    # Granger causality tests
    gr_p = {}
    for col in ['RSI', 'EMA50', 'EMA100']:
        res = grangercausalitytests(df[['Return', col]], maxlag=5, verbose=False)
        gr_p[col] = [res[i+1][0]['ssr_ftest'][1] for i in range(5)]
    results['granger'] = pd.DataFrame(gr_p, index=[f'lag_{i+1}' for i in range(5)])

    # RSI t-tests (overbought/oversold)
    over = df[df['RSI'] > 70]['Return']
    under = df[df['RSI'] < 30]['Return']
    neutral = df[(df['RSI'] >= 30) & (df['RSI'] <= 70)]['Return']
    t1 = ttest_ind(over, neutral, nan_policy='omit')
    t2 = ttest_ind(under, neutral, nan_policy='omit')
    results['ttest'] = pd.DataFrame([
        {'Comparison': 'Overbought vs Neutral', 't_stat': t1.statistic, 'p_value': t1.pvalue},
        {'Comparison': 'Oversold vs Neutral', 't_stat': t2.statistic, 'p_value': t2.pvalue}
    ])

    # Mutual information (for non-linear relationships)
    mi = []
    for col in ['RSI','EMA50','EMA100']:
        mi.append({'Indicator': col,
                   'Mutual_Info': mutual_info_regression(df[[col]], df['Return'], random_state=0)[0]})
    results['mi'] = pd.DataFrame(mi)

    # Simple strategy backtest for RSI and EMAs
    pos_rsi    = pd.Series(0, index=df.index)
    pos_rsi[df['RSI'] < 30] = 1
    pos_rsi[df['RSI'] > 70] = 0
    pos_rsi = pos_rsi.ffill().fillna(0)
    pos_ema50  = (df['Close'] > df['EMA50']).astype(int)
    pos_ema100 = (df['Close'] > df['EMA100']).astype(int)

    strat = pd.DataFrame({
        'RSI_Strategy':    pos_rsi.shift(1)*df['Return'],
        'EMA50_Strategy':  pos_ema50.shift(1)*df['Return'],
        'EMA100_Strategy': pos_ema100.shift(1)*df['Return']
    }).dropna()

    equity = (1 + strat).cumprod()
    equity['BuyHold'] = (1 + df['Return']).cumprod()

    # Strategy metrics (return, Sharpe, drawdown)
    ann = np.sqrt(252*24)
    perf = []
    for strat_nm in ['RSI_Strategy','EMA50_Strategy','EMA100_Strategy']:
        tot_ret = equity[strat_nm].iloc[-1] - 1
        shr     = strat[strat_nm].mean() / strat[strat_nm].std() * ann
        dd      = (equity[strat_nm] / equity[strat_nm].cummax() - 1).min()
        perf.append({'Strategy': strat_nm, 'Total Return': tot_ret, 'Sharpe': shr, 'Max Drawdown': dd})
    results['performance'] = pd.DataFrame(perf)

    # One-sample t-test against zero return
    pv = []
    for strat_nm in ['RSI_Strategy','EMA50_Strategy','EMA100_Strategy']:
        pv.append({'Strategy': strat_nm, 'p_value': ttest_1samp(strat[strat_nm], 0).pvalue})
    results['pval'] = pd.DataFrame(pv)

    # Save equity and returns for plotting
    results['equity'] = equity
    results['strat'] = strat
    return results

# 6) Run everything for each timeframe
for tf in timeframes:
    df_tf = df_raw.resample(tf).last().dropna()
    df_ind = compute_indicators(df_tf.copy())
    all_results[tf] = analyze(df_ind)

# 7) Show all results and plots
for tf in timeframes:
    r = all_results[tf]
    print(f"\n\n=== {tf} ===")
    display(r['correlation'])
    display(r['linreg'].summary())
    print(f"AUC: {r['auc']:.4f}")
    display(r['granger'])
    display(r['ttest'])
    display(r['mi'])
    display(r['performance'])
    display(r['pval'])

    # Plot equity curves
    plt.figure(figsize=(10,4))
    for col in r['equity'].columns:
        plt.plot(r['equity'].index, r['equity'][col], label=col)
    plt.title(f"Equity Curves - {tf}")
    plt.legend(); plt.grid(); plt.show()

    # Plot Sharpe ratios
    plt.figure(figsize=(6,4))
    sns.barplot(data=r['performance'], x='Strategy', y='Sharpe')
    plt.title(f"Sharpe Ratios - {tf}")
    plt.show()

    # Plot p-values
    plt.figure(figsize=(6,4))
    sns.barplot(data=r['pval'], x='Strategy', y='p_value')
    plt.axhline(0.05, linestyle='--', color='red', label='α=0.05')
    plt.legend(); plt.title(f"Strategy p-values - {tf}")
    plt.show()
